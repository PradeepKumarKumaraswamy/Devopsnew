#This code executes Network telemetry data subscription on routers and identifies interface flaps on L2/L3 services in the Network Stack example bgp,ospf, ldp etc 
puts "Subscription proc usage syntax: telemetry_pull  \"Protocol\" \"Dutname\""
puts "checking proc usage syntax: telemetry_check  \"Protocol\" \"Dutname\"" 
 

proc telemetry_subscribe { {path} {dut} {strName "stream0"} args} {
   upvar 1 $path pathnew
   #set WRITE1 [open "~/pradeep/subscribe.txt" w]
   
   $dut getMgmtCommand "" -array pathnew -mode gmi -request stream -streamName $strName -process nonBlocking
   $dut streamHandler "" -streamName $strName -replyValues reply -request get-pairs
   

   unset path
   if { [info exist reply(count)]} {unset reply(count)}
   if { [info exist reply(state)]} {unset reply(state)}
   if { [info exist reply(ok)]} {unset reply(ok)}
   if { [info exist reply(state,detail)]} {unset reply(state,detail)}
   
   # foreach item [array names reply] {
      # puts $WRITE1 $reply($item)
   # }
   
   
   # close $WRITE1
   
   if {![info exists reply]} {
      puts "NO SUBSCRIPTION DATA"
	  return
   }
  
   return [array get reply]
   #interpreter
}


proc parse {reply} {
   upvar 1 $reply replytmp
   foreach n [array names replytmp] {
      if {[regexp {state router <Base> bgp neighbor <(\d+\.\d+\.\d+\.\d+|[\w:]+:+[\w:]+)> statistics (last-established-time)} $replytmp($n) match nbrip attribute]} {
		   set value [lindex $replytmp($n) end]
		   if {[string equal $attribute "last-established-time"]} {
		       regexp {\d+-\d+-\d+T\d+\:\d+} $value tim
               dict set tmp bgp $nbrip $attribute $tim
			} else {
		       dict set tmp bgp $nbrip $attribute $value
			}
	  } elseif {[regexp {state router <Base> ospf <(\d+)> area <(\d+\.\d+\.\d+\.\d+|[\w:]+:+[\w:]+)> interface <([a-zA-Z0-9 -/:_]*)> neighbor-state <(\d+\.\d+\.\d+\.\d+)> (last-event-time)} $replytmp($n) match id areaid intr nbrip attribute]} {
	       set value [lindex $replytmp($n) end]
		    if {[string equal $attribute "last-event-time"]} {
		       regexp {\d+-\d+-\d+T\d+\:\d+} $value tim
               dict set tmp ospf $id $areaid $intr $nbrip $attribute $tim
			} else {
		       dict set tmp ospf $id $areaid $intr $nbrip $attribute $value
			}
      } elseif {[regexp {state router <Base> isis <(\d+)> interface <([a-zA-Z0-9 -/:_]*)> (up-time)} $replytmp($n) match id intr attribute]} {
	       set value [lindex $replytmp($n) end]
		   dict set tmp isis $id $intr $attribute $value
	  } elseif {[regexp {state router <Base> ldp session <(\d+\.\d+\.\d+\.\d+\:\d+|[\w:]+:+[\w:\[\]]+)> (up-time)} $replytmp($n) match ip attribute]} {
	       set value [lindex $replytmp($n) end]
		   dict set tmp ldp $ip $attribute $value
	  } else {
	     continue
      }
   }
   #interpreter
   if {[info exist tmp]} {
      return $tmp 
   } else { 
      #puts "No subscription Data exist"
	  return 
   }
  
}

proc cleanup_telemetry {{duration long} {duts all} {verbose noisy} args} {
   global stb_globals dut_list env gmi_global
   if {$duts == "all"} {
      set duts $dut_list
   }

   foreach dut $duts {
      GMI::enviroment_cleanup -duts $dut
   }
   
}


proc printdata {{data} {protocol} args} {
   
   set formatStr {%40s%15s}
   puts [format $formatStr "Key" "Value"]
   puts $protocol
   set datanew [dict get $data $protocol]
   dict for {key value} $datanew {
     dict for {k2 v2} $value {
	   puts [format $formatStr $key:$k2 \t$v2]
	 }
   }
   
}


proc telemetry_pull { {proto all} {duts all} args} {
   global tele timefirst dut_list env gmi_global
   stopwatch_init w1
   
   if { $proto == "all" } {
      set proto [list 'bgp','ospf','ldp']
   }
   
   if {$duts == "all"} {
      set duts $dut_list
   }

   set i 1
   
  
      foreach item $proto {   
         if { $item == "bgp" } {
            set path($i) "state router <Base> bgp neighbor <*> statistics last-established-time"
         } elseif { $item == "ospf" } {
            set path($i) "state router <Base> ospf <*> area <*> interface <*> neighbor-state <*> last-event-time"
         } elseif { $item == "isis" } {
            set path($i) "state router <Base> isis <*> interface <*> up-time"
         } elseif { $item == "ldp" } {
         } elseif { $item == "ldp" } {
            set path($i) "state router <Base> ldp session <*> up-time"
         } else {
            puts "Invalid Protocol"
            return
         }
	     incr i
      }
	 
   set formatStr {%50s%50s}	
   foreach dut $duts {
      puts [format $formatStr "\n--------------***----------------" "-------------------***-----------------" ]
      puts "\n Asynchronous Subscrition in Dut $dut"
	  array set asynchronous_reply.$dut [telemetry_subscribe path $dut stream$dut]
   }
}
 

proc telemetry_write { {dut} {strName} args} {
   global dut_list env gmi_global
   $dut streamHandler "" -streamName $strName -replyValues reply -request get-pairs
   if {$reply(state) == "finished" && $reply(count) > 0 } {
      return [array get reply]
   } elseif { $reply(ok) == "FAILED" } {
      puts " Subscription failed "
	  return
   } else {
      puts "No data"
      return
   }
}
  
  
proc telemetry_check { {duts all} args} {
   
   global tele timefirst dut_list env gmi_global
   
   
   if {$duts == "all"} {
      set duts $dut_list
   }
   set formatStr {%50s%50s}
   foreach dut $duts {
      puts [format $formatStr "\n--------------***----------------" "-------------------***-----------------" ]
      puts "\nDut in execution is $dut"
      if {[info exists gmi_global($dut.tele)]} {
         #array set reply.$dut [telemetry_subscribe path $dut stream$dut]
		 array set reply.$dut [telemetry_write $dut stream$dut]
	     set gmi_global($dut.teletmp) [parse reply.$dut] 
	     puts "Temporary subscription data"
	     puts "[dict get $gmi_global($dut.teletmp)]\n"
	     set timecurrent [clock milliseconds]
	     #dict get $teletmp
	  
	    
	           dict for {protocol values} $gmi_global($dut.teletmp) { 
			
	              if {$protocol == "ospf"} {
			   
						if {[dict exists $gmi_global($dut.tele) $protocol]} {
	                    dict for {ospfid ospfvalue} $values {
                         dict for {areaid areavalue} $ospfvalue {
                          dict for {interface interface_value} $areavalue {
                           dict for {nbrip nbripvalue} $interface_value {
                            dict for {lastEstTime lastEstTime_value} $nbripvalue {
				          #interpreter
                             if {[dict get $gmi_global($dut.tele) ospf $ospfid $areaid $interface $nbrip $lastEstTime] != [dict get $gmi_global($dut.teletmp) ospf $ospfid $areaid $interface $nbrip $lastEstTime]} {
					      #interpreter
			                    puts "ospf '$ospfid $areaid $interface $nbrip $lastEstTime' Flapped from [dict get $gmi_global($dut.tele) ospf $ospfid $areaid $interface $nbrip $lastEstTime] to [dict get $gmi_global($dut.teletmp) ospf $ospfid $areaid $interface $nbrip $lastEstTime]"
				                dict set gmi_global($dut.tele) ospf $ospfid $areaid $interface $nbrip $lastEstTime [dict get $gmi_global($dut.teletmp) ospf $ospfid $areaid $interface $nbrip $lastEstTime]
                             } else {
						        dict create gmi_global($dut.tele) ospf $ospfid $areaid $interface $nbrip $lastEstTime [dict get $gmi_global($dut.teletmp) ospf $ospfid $areaid $interface $nbrip $lastEstTime] 
						     }
                        }}}}}
	   
	                } else  {
				        puts "New $protocol data appended"
				        dict append gmi_global($dut.tele) $protocol $values
                    }
					#interpreter
					printdata $gmi_global($dut.tele) $protocol
			      } 
				  
			     if {$protocol == "ldp"} {
			   
				    if {[dict exists $gmi_global($dut.tele) $protocol]} {
	                   dict for {ldpip ldpvalue} $values {
                        dict for {uptime uptimevalue} $ldpvalue {
				         set elapsed_time [expr {$timecurrent - $timefirst($dut.$protocol)}]
				         set totaltimeldp [expr {$elapsed_time + [dict get $gmi_global($dut.tele) ldp $ldpip $uptime]}]
                            if {[dict get $gmi_global($dut.tele) ldp $ldpip $uptime] > [dict get $gmi_global($dut.teletmp) ldp $ldpip $uptime] || $totaltimeldp > [dict get $gmi_global($dut.teletmp) ldp $ldpip $uptime]} {
			                   puts "ldp '$ldpip $uptime' Flapped from [dict get $gmi_global($dut.tele) ldp $ldpip $uptime] to [dict get $gmi_global($dut.teletmp) ldp $ldpip $uptime]"
				               dict set gmi_global($dut.tele) ldp $ldpip $uptime  [dict get $gmi_global($dut.teletmp) ldp $ldpip $uptime ] 
			                } else {
						       dict set gmi_global($dut.tele) ldp $ldpip $uptime  [dict get $gmi_global($dut.teletmp) ldp $ldpip $uptime ] 
						    }
 		               }}
	               } else  {
					  puts "New $protocol data appended"
				      dict append gmi_global($dut.tele) $protocol $values
                   }
				   printdata $gmi_global($dut.tele) $protocol
				   set timefirst($dut.$protocol) [clock milliseconds] 
	            }
				
				if {$protocol == "bgp"} {
				
				   if {[dict exists $gmi_global($dut.tele) $protocol]} {
	                  dict for {nbrip nbripvalue} $values {
                       dict for {lastEstTime lastEstTime_timevalue} $nbripvalue {
	                    if {[dict get $gmi_global($dut.tele) bgp $nbrip $lastEstTime] != [dict get $gmi_global($dut.teletmp) bgp $nbrip $lastEstTime]} {
			              puts "bgp '$nbrip $lastEstTime' Flapped from [dict get $gmi_global($dut.tele) bgp $nbrip $lastEstTime] to [dict get $gmi_global($dut.teletmp) bgp $nbrip $lastEstTime]"
				          dict set gmi_global($dut.tele) bgp $nbrip $lastEstTime [dict get $gmi_global($dut.teletmp) bgp $nbrip $lastEstTime] 
			            } else {
						   dict set gmi_global($dut.tele) bgp $nbrip $lastEstTime [dict get $gmi_global($dut.teletmp) bgp $nbrip $lastEstTime] 
						}
		              }}
	               } else  {
				      puts "New $protocol data appended"
				      dict append gmi_global($dut.tele) $protocol $values
                   }
				#interpreter
				printdata $gmi_global($dut.tele) $protocol
				}
			}
			
			
	  		
     } else {
        #array set reply.$dut [telemetry_subscribe path $dut stream$dut]
		#interpreter
		puts "Initial write"
        array set reply.$dut [telemetry_write $dut stream$dut]
	    set gmi_global($dut.tele) [parse reply.$dut] 
        #puts "[dict get $gmi_global($dut.tele)]"
	    dict for {protocol value} $gmi_global($dut.tele) {
	      set timefirst($dut.$protocol) [clock milliseconds]
		  printdata $gmi_global($dut.tele) $protocol
		  #interpreter
        }
     }
	 
   }
}

